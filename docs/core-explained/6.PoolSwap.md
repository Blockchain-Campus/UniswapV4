---
sidebar_position: 6
---

# Pool Swap

In the previous section, we provided an overview of the entire swap process, but we have not yet analyzed how `pool.swap(params)` is actually executed. Now, let's dive into `src/libraries/Pool.sol` to understand how token swaps occur within the contract.

```solidity
struct SwapParams {
    int256 amountSpecified;
    int24 tickSpacing;
    bool zeroForOne;
    uint160 sqrtPriceLimitX96;
    uint24 lpFeeOverride;
}

function swap(State storage self, SwapParams memory params)
        internal
        returns (BalanceDelta swapDelta, uint256 amountToProtocol, uint24 swapFee, SwapResult memory result)
    {
```

As seen in the code above, the `swap` function's input data structure is `SwapParams`. Let's analyze the role of each parameter in `SwapParams`. The `amountSpecified` parameter represents the exact amount of tokens the user wants to send to or receive from the pool.

`tickSpacing` determines the intervals at which ticks are searched (for example, 1, 10, or 20). Ticks can only be searched at increments defined by `tickSpacing`. Smaller `tickSpacing` values provide greater liquidity to complete the swap, resulting in more accurate transactions and reduced slippage. However, this comes at the cost of higher gas fees due to more extensive tick searches. 

It represents a trade-off between lower accuracy and higher slippage with reduced gas costs, or higher accuracy and lower slippage with increased gas costs.

`zeroForOne` indicates whether `token0` is being swapped for `token1` or the reverse.  

`sqrtPriceLimitX96` serves as price range protection, ensuring that swaps occur within a specified limit. This mechanism prevents slippage from exceeding the user's maximum allowable threshold.

`lpFeeOverride` works in conjunction with hooks to enable dynamic fees for swaps. If the hook overrides the liquidity provider (LP) fee before the swap is executed, the swap uses the overridden fee. Otherwise, the default swap fee is applied.

Now, let's take a closer look at the execution of the `swap` function.

```solidity
int256 amountSpecifiedRemaining = params.amountSpecified;
int256 amountCalculated = 0;
// initialize to the current sqrt(price)
result.sqrtPriceX96 = slot0Start.sqrtPriceX96();
// initialize to the current tick
result.tick = slot0Start.tick();
// initialize to the current liquidity
result.liquidity = self.liquidity;
```

The following code sets up the initial state for the swap. The `amountSpecifiedRemaining` variable is initialized based on the amount of tokens the user wishes to swap. 

Why do we use "remaining" to name this variable? This is because the liquidity at a given tick may not fully satisfy the user's swap request. In such cases, the swap process continues searching for liquidity at the next tick. Therefore, we need a parameter to track the number of tokens that still need to be swapped during this process.

To complement `amountSpecifiedRemaining`, the `amountCalculated` variable represents the tokens already obtained from the swap. Its initial value is set to 0.

```solidity
uint24 lpFee = params.lpFeeOverride.isOverride()
                ? params.lpFeeOverride.removeOverrideFlagAndValidate()
                : slot0Start.lpFee();

swapFee = protocolFee == 0 ? lpFee : uint16(protocolFee).calculateSwapFee(lpFee);
```

`lpFee` represents the fee paid to the liquidity provider. As mentioned earlier in the `lpFeeOverride` parameter explanation, if the hook adjusts this value, the fee provided by the hook is used as the LP fee. Otherwise, the default fee is applied.

`swapFee` represents the total fee, which combines the protocol fee and the liquidity provider fee for this swap. The calculation of the total fee is as follows:

```solidity
// protocolFee + lpFee(1_000_000 - protocolFee) / 1_000_000 (rounded up)
```

From the calculation method, we can see that the final fee is not simply the sum of `protocolFee` and `lpFee`. Instead, the swapping tokens are first charged the `protocolFee`, and the remaining tokens are then subject to the `lpFee`.

```solidity
if (zeroForOne) {
    if (params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96()) {
        PriceLimitAlreadyExceeded.selector.revertWith(slot0Start.sqrtPriceX96(), params.sqrtPriceLimitX96);
    }
    // Swaps can never occur at MIN_TICK, only at MIN_TICK + 1, except at initialization of a pool
    // Under certain circumstances outlined below, the tick will preemptively reach MIN_TICK without swapping there
    if (params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_PRICE) {
        PriceLimitOutOfBounds.selector.revertWith(params.sqrtPriceLimitX96);
    }
} else {
    if (params.sqrtPriceLimitX96 <= slot0Start.sqrtPriceX96()) {
        PriceLimitAlreadyExceeded.selector.revertWith(slot0Start.sqrtPriceX96(), params.sqrtPriceLimitX96);
    }
    if (params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_PRICE) {
        PriceLimitOutOfBounds.selector.revertWith(params.sqrtPriceLimitX96);
    }
}
```

If `zeroForOne` is true, it indicates that the user wants to swap `token0` for `token1`. In this case, the price curve will decline during the swap. However, if `params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96()`, it means the user's minimum swap price limit is higher than the current price. As a result, the swap will not proceed.

Similarly, if `zeroForOne` is false, the user intends to swap `token1` for `token0`, causing the price curve to rise during the swap. In this scenario, the limit swap price `params.sqrtPriceLimitX96` must be higher than the current price; otherwise, the swap will fail.

```solidity
StepComputations memory step;
step.feeGrowthGlobalX128 = zeroForOne ? self.feeGrowthGlobal0X128 : self.feeGrowthGlobal1X128;

while (!(amountSpecifiedRemaining == 0 || result.sqrtPriceX96 == params.sqrtPriceLimitX96)) 
{...}
```

Next, we initialize the variable `feeGrowthGlobalX128` to facilitate the accumulation of LP fees. In the following part, we will dive into the while loop to explore how tick liquidity is searched and how the swap is executed.

```solidity
// Inside the while loop
(step.tickNext, step.initialized) =
self.tickBitmap.nextInitializedTickWithinOneWord(result.tick, params.tickSpacing, zeroForOne);

if (step.tickNext <= TickMath.MIN_TICK) {
    step.tickNext = TickMath.MIN_TICK;
}
if (step.tickNext >= TickMath.MAX_TICK) {
    step.tickNext = TickMath.MAX_TICK;
}
step.sqrtPriceNextX96 = TickMath.getSqrtPriceAtTick(step.tickNext);
```

