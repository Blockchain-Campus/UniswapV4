---
sidebar_position: 7
---

# Flash Accounting

In the previous section, we frequently mentioned the variable `delta` and the concept of “Flash Accounting.” But what do these terms actually mean?

In Uniswap V3 and earlier versions, swapping across pools—for example, exchanging ETH for DAI—typically required intermediary swaps. First, ETH would be swapped for USDC, and then USDC would be swapped for DAI. At each stage, tokens needed to be transferred between accounts (via `transfer` calls). Although a router contract could handle these interactions on behalf of the user, multiple transfer calls were still required, either initiated by the router contract or directly by the user.

With the introduction of **EIP-1153** during the Dencun upgrade, a new approach called “Flash Accounting” was introduced. This method replaces the need to write data into persistent storage during every swap step. Instead, it leverages transient storage to temporarily store intermediate calculations, deferring all updates until the final step. This mechanism significantly reduces gas costs associated with storage operations and token transfers. The term “Flash” in Flash Accounting reflects the efficiency and temporary nature of this accounting system, as it performs calculations and updates in a swift, non-permanent manner before finalizing the transaction.



## EIP-1153

The main role of [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153) is to involve transient storage by using two opcodes, `TLOAD` and `TSTORE`, where “T” stands for “transient:”  

Transient storage is a new writable data location that is persistent for the duration of a transaction. Because the blockchain doesn’t need to store transient data after the transaction (and thus nodes don’t have to use disk), it is significantly less expensive than traditional storage.

The core purpose of EIP-1153 is to optimize **the storage of intermediate states during a transaction’s lifecycle** by reducing the frequency of reads and writes to on-chain storage. This enhancement significantly lowers gas costs, particularly in scenarios where transient data is repeatedly accessed or modified during a transaction. For example, while traditional storage operations require 2100 gas for a cold read and 2900 gas for a dirty write, the new opcodes `TLOAD` and `TSTORE` consume only 100 gas each. This difference highlights the efficiency of transient storage in minimizing gas consumption.

The basic use case of EIP-1153 is to replace the reentrancy guard based on storage. You can read [Demystifying EIP-1153: Transient Storage](https://medium.com/@organmo/demystifying-eip-1153-transient-storage-faeabbadd0d) to learn more about this.

Data stored using transient opcodes is valid only within a single transaction and is cleared afterward. Some may think it’s acceptable to “lock” without “unlocking” since all transient storage data is cleared once the transaction is completed. However, this is not a good practice. While it may save 100 gas, it compromises the contract’s composability. For more information, refer to [Transient Storage Opcodes in Solidity 0.8.24](https://soliditylang.org/blog/2024/01/26/transient-storage/).

In Uniswap V4, all on-chain data modifications must go through the unlock function first. The unlock function serves as the reentrancy guard in Uniswap V4.

```solidity
// src/PoolManager.sol
function unlock(bytes calldata data) external override returns (bytes memory result) {
    if (Lock.isUnlocked()) AlreadyUnlocked.selector.revertWith();
    Lock.unlock();
    // the caller does everything in this callback, including paying what they owe via calls to settle
    result = IUnlockCallback(msg.sender).unlockCallback(data);
    if (NonzeroDeltaCount.read() != 0) CurrencyNotSettled.selector.revertWith();
    Lock.lock();
}
```

By examining the `Lock` design, we can observe that it utilizes EIP-1153 to implement the reentrancy guard. The Lock library uses transient storage to manage the lock state during the transaction. Specifically, the `IS_UNLOCKED_SLOT` constant defines a transient storage slot where the lock state is stored. The `unlock` and `lock` functions set the transient storage state to true or false respectively using the `tstore` opcode, while the `isUnlocked` function retrieves the current lock state using the `tload` opcode.

```solidity
// src/libraries/Lock.sol
library Lock {
    // The slot holding the unlocked state, transiently. bytes32(uint256(keccak256("Unlocked")) - 1)
    bytes32 internal constant IS_UNLOCKED_SLOT = 0xc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab23;
    
    function unlock() internal {
        assembly ("memory-safe") {
            // unlock
            tstore(IS_UNLOCKED_SLOT, true)
        }
    }
    function lock() internal {
        assembly ("memory-safe") {
            tstore(IS_UNLOCKED_SLOT, false)
        }
    }
    function isUnlocked() internal view returns (bool unlocked) {
        assembly ("memory-safe") {
            unlocked := tload(IS_UNLOCKED_SLOT)
        }
    }
}
```



## Flash Accounting

In the previous section, we observed that whenever liquidity is modified, or a swap occurs, the function _accountPoolBalanceDelta is invoked. This function is, in fact, the core of Flash Accounting. By utilizing this function, delta information can be stored temporarily in transient storage. During the transaction’s execution—such as when swapping tokens across multiple pools—this temporary delta information can be read and modified. Finally, at the conclusion of the transaction, the `take` and `settle` methods are used to reconcile the token balances.

```solidity
// src/PoolManager.sol
function modifyLiquidity(
        PoolKey memory key,
        IPoolManager.ModifyLiquidityParams memory params,
        bytes calldata hookData
    ) external onlyWhenUnlocked noDelegateCall returns (BalanceDelta callerDelta, BalanceDelta feesAccrued) {
    ...
    callerDelta = principalDelta + feesAccrued;
    ...
    _accountPoolBalanceDelta(key, callerDelta, msg.sender);
}

function swap(PoolKey memory key, IPoolManager.SwapParams memory params, bytes calldata hookData)
        external
        onlyWhenUnlocked
        noDelegateCall
        returns (BalanceDelta swapDelta)
{
    ...
    _accountPoolBalanceDelta(key, swapDelta, msg.sender);
}
```

Now, let's take a deep look at `_accountPoolBalanceDelta` to observe its design.

```solidity
function _accountPoolBalanceDelta(PoolKey memory key, BalanceDelta delta, address target) internal {
    _accountDelta(key.currency0, delta.amount0(), target);
    _accountDelta(key.currency1, delta.amount1(), target);
}
function _accountDelta(Currency currency, int128 delta, address target) internal {
    if (delta == 0) return;

    (int256 previous, int256 next) = currency.applyDelta(target, delta);

    if (next == 0) {
        NonzeroDeltaCount.decrement();
    } else if (previous == 0) {
        NonzeroDeltaCount.increment();
    }
}
```



We should note that for the Uniswap swap model involving reading and modifying data, EIP-1153 cannot directly save gas. This is because reading the pool’s token state and writing the updated token data are necessary operations that cannot be skipped (involving both code reads and dirty writes). However, in Uniswap V3 and earlier versions, when swapping tokens across multiple pools, each pool crossing required multiple transfer calls. These operations generated significant gas consumption.

With EIP-1153 and the singleton pool design, there is no need to perform actual token transfers for each pool crossing. Instead, temporary data is stored in transient storage, and the final token state is written to the blockchain only once at the end of the transaction. This means that only a single transfer is executed instead of performing multiple transfers, significantly reducing gas costs.









这就是为什么在计算完 delta（流动性变化）之后，还需要检查并退还可能的剩余 ETH。这不影响流动性的添加或修改操作，而是作为一个安全和便利的清理步骤。

这个设计在 Uniswap V4 的白皮书中也有提到（参考 whitepaper 中的 Native ETH 部分）











